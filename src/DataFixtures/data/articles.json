[
  {
    "title": "Big-O Notation: Laufzeitkomplexität verstehen",
    "content": "Die Big-O-Notation beschreibt die obere Grenze der Laufzeit eines Algorithmus in Abhängigkeit von der Eingabegröße n.\n\nWichtige Klassen: O(1) konstant, O(log n) logarithmisch, O(n) linear, O(n log n) für viele Sortierverfahren, O(n²) quadratisch.\n\nBeispiel: Eine lineare Suche im Array hat O(n), da im Worst Case jedes Element geprüft wird.",
    "created_at": "2025-09-15T10:30:00Z",
    "published_at": "2025-09-17T14:45:00Z",
    "article_type": "Erklärung",
    "author_email": "redak1@test.de",
    "course_slug": "algorithmen-datenstrukturen"
  },
  {
    "title": "Binärbäume und Traversierung",
    "content": "Ein Binärbaum ist eine Datenstruktur, bei der jeder Knoten höchstens zwei Kinder hat (links und rechts).\n\nTraversierungen: Inorder (L-W-R) ergibt bei BST eine sortierte Folge, Preorder (W-L-R), Postorder (L-R-W).\n\nAnwendung: Suchbäume, Heaps, Ausdrucksbäume.",
    "created_at": "2025-09-20T09:00:00Z",
    "published_at": "2025-09-21T11:00:00Z",
    "article_type": "Erklärung",
    "author_email": "redak2@test.de",
    "course_slug": "algorithmen-datenstrukturen"
  },
  {
    "title": "Hash-Tabellen: Aufbau und Kollisionsbehandlung",
    "content": "Hash-Tabellen speichern Schlüssel-Wert-Paare und erlauben durch eine Hashfunktion im Mittel O(1) Zugriff.\n\nKollisionen entstehen, wenn verschiedene Schlüssel denselben Hash erzeugen. Lösungen: Verkettung (Chaining) oder offene Adressierung (z.B. lineares Sondieren).\n\nWichtig: Gute Hashfunktion verteilt die Schlüssel gleichmäßig.",
    "created_at": "2025-09-25T14:00:00Z",
    "published_at": "2025-09-26T10:30:00Z",
    "article_type": "Erklärung",
    "author_email": "redak1@test.de",
    "course_slug": "algorithmen-datenstrukturen"
  },
  {
    "title": "Beispielklausur: Algorithmen und Datenstrukturen (Teil 1)",
    "content": "Aufgabe 1: Bestimmen Sie die Laufzeitkomplexität von MergeSort in Big-O-Notation und begründen Sie kurz.\n\nAufgabe 2: Gegeben sei ein binärer Suchbaum. Geben Sie die Reihenfolge der Knoten bei Inorder-Traversierung an.\n\nAufgabe 3: Erläutern Sie den Unterschied zwischen einer einfach verketteten und einer doppelt verketteten Liste.",
    "created_at": "2025-10-01T08:00:00Z",
    "published_at": "2025-10-02T09:00:00Z",
    "article_type": "Beispielklausur",
    "author_email": "redak3@test.de",
    "course_slug": "algorithmen-datenstrukturen",
    "upload_filename": "beispielklausur-algorithmen-teil1.pdf"
  },
  {
    "title": "Beispielklausur: Graphen und kürzeste Wege",
    "content": "Aufgabe 1: Beschreiben Sie den Algorithmus von Dijkstra zur Berechnung kürzester Wege von einer Quelle zu allen anderen Knoten.\n\nAufgabe 2: Unter welchen Bedingungen liefert der Bellman-Ford-Algorithmus korrekte Ergebnisse, wo Dijkstra versagt?\n\nAufgabe 3: Nennen Sie die Laufzeitkomplexität von BFS und DFS bei n Knoten und m Kanten.",
    "created_at": "2025-10-05T12:00:00Z",
    "published_at": "2025-10-06T14:00:00Z",
    "article_type": "Beispielklausur",
    "author_email": "redak2@test.de",
    "course_slug": "algorithmen-datenstrukturen",
    "upload_filename": "beispielklausur-graphen-kuerzeste-wege.pdf"
  },
  {
    "title": "Karteikarten: Grundbegriffe Algorithmen",
    "content": "Rückseite: Was ist ein Algorithmus?\nVorderseite: Eine endliche, eindeutige Anweisungsfolge zur Lösung eines Problems.\n\n---\nRückseite: Was bedeutet „in-place“?\nVorderseite: Ein Algorithmus arbeitet in-place, wenn er nur konstanten zusätzlichen Speicher (außer der Eingabe) benötigt.\n\n---\nRückseite: Stabile Sortierung?\nVorderseite: Relative Reihenfolge gleicher Schlüssel bleibt erhalten (z.B. MergeSort stabil, Quicksort nicht).",
    "created_at": "2025-10-10T09:30:00Z",
    "published_at": "2025-10-11T11:00:00Z",
    "article_type": "Karteikarten",
    "author_email": "user1@test.de",
    "course_slug": "algorithmen-datenstrukturen",
    "upload_filename": "karteikarten-grundbegriffe-algorithmen.pdf"
  },
  {
    "title": "Karteikarten: Datenstrukturen Laufzeiten",
    "content": "Array: Zugriff O(1), Suche O(n), Einfügen am Ende O(1), Einfügen in der Mitte O(n).\n\nBinärer Suchbaum: Suche/Einfügen/Löschen im Mittel O(log n), im Worst Case O(n).\n\nHash-Tabelle: Erwartet O(1) für Einfügen, Löschen, Suche bei guter Hashfunktion.",
    "created_at": "2025-10-12T10:00:00Z",
    "published_at": "2025-10-13T09:00:00Z",
    "article_type": "Karteikarten",
    "author_email": "user2@test.de",
    "course_slug": "algorithmen-datenstrukturen",
    "upload_filename": "karteikarten-datenstrukturen-laufzeiten.pdf"
  },
  {
    "title": "Karteikarten: Sortieralgorithmen",
    "content": "BubbleSort: O(n²), stabil, in-place.\nMergeSort: O(n log n), stabil, nicht in-place.\nQuickSort: O(n log n) erwartet, O(n²) Worst Case, nicht stabil, in-place möglich.\nHeapSort: O(n log n), nicht stabil, in-place.",
    "created_at": "2025-10-14T14:00:00Z",
    "published_at": "2025-10-15T08:30:00Z",
    "article_type": "Karteikarten",
    "author_email": "redak1@test.de",
    "course_slug": "algorithmen-datenstrukturen",
    "upload_filename": "karteikarten-sortieralgorithmen.pdf"
  }
]
